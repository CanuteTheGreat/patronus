//! L2TP VPN (Layer 2 Tunneling Protocol)
//!
//! Provides L2TP/IPsec VPN server for road warrior clients.
//! Often used by mobile devices and legacy systems.

use patronus_core::{Result, Error};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::path::PathBuf;
use tokio::process::Command;

/// L2TP server configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2tpConfig {
    pub enabled: bool,

    // Server settings
    pub listen_address: IpAddr,
    pub local_ip: IpAddr,           // VPN server IP
    pub remote_ip_range: String,    // Client IP range "10.2.0.2-10.2.0.254"

    // Authentication
    pub preshared_key: String,      // IPsec PSK
    pub auth_type: L2tpAuthType,
    pub require_chap: bool,
    pub require_mschap: bool,
    pub require_mschapv2: bool,

    // User database
    pub users: Vec<L2tpUser>,
    pub radius_auth: bool,
    pub radius_server: Option<IpAddr>,
    pub radius_secret: Option<String>,

    // DNS servers for clients
    pub dns_servers: Vec<IpAddr>,
    pub wins_servers: Vec<IpAddr>,

    // Advanced
    pub mtu: u16,
    pub mru: u16,
    pub lcp_echo_interval: u32,
    pub lcp_echo_failure: u32,
    pub require_encryption: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum L2tpAuthType {
    PAP,
    CHAP,
    MSCHAP,
    MSCHAPv2,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2tpUser {
    pub username: String,
    pub password: String,
    pub enabled: bool,
    pub static_ip: Option<IpAddr>,  // Assign specific IP to user
}

/// L2TP connection status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2tpConnection {
    pub username: String,
    pub client_ip: IpAddr,
    pub tunnel_id: u32,
    pub session_id: u32,
    pub connected_at: chrono::DateTime<chrono::Utc>,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

pub struct L2tpManager {
    config: L2tpConfig,
}

impl L2tpManager {
    pub fn new(config: L2tpConfig) -> Self {
        Self { config }
    }

    /// Configure L2TP server
    pub async fn configure(&self) -> Result<()> {
        tracing::info!("Configuring L2TP/IPsec VPN server");

        // Configure IPsec for L2TP
        self.configure_ipsec().await?;

        // Configure xl2tpd (L2TP daemon)
        self.configure_xl2tpd().await?;

        // Configure PPP options
        self.configure_ppp().await?;

        // Create user secrets
        self.create_user_secrets().await?;

        // Create systemd services
        self.create_systemd_services().await?;

        Ok(())
    }

    async fn configure_ipsec(&self) -> Result<()> {
        // IPsec configuration for L2TP (using strongSwan)
        let ipsec_conf = format!(r#"# IPsec configuration for L2TP
# Generated by Patronus

config setup
    charondebug="ike 1, knl 1, cfg 0"
    uniqueids=no

conn L2TP-PSK
    authby=secret
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=1h
    type=transport
    left={}
    leftprotoport=17/1701
    right=%any
    rightprotoport=17/%any
    dpddelay=30
    dpdtimeout=120
    dpdaction=clear
"#, self.config.listen_address);

        tokio::fs::write("/etc/ipsec.conf", ipsec_conf).await?;

        // IPsec secrets (PSK)
        let ipsec_secrets = format!(r#"# IPsec secrets for L2TP
# Generated by Patronus

: PSK "{}"
"#, self.config.preshared_key);

        tokio::fs::write("/etc/ipsec.secrets", ipsec_secrets).await?;

        // Set restrictive permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata("/etc/ipsec.secrets").await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            tokio::fs::set_permissions("/etc/ipsec.secrets", perms).await?;
        }

        Ok(())
    }

    async fn configure_xl2tpd(&self) -> Result<()> {
        // xl2tpd configuration
        let xl2tpd_conf = format!(r#"# xl2tpd configuration
# Generated by Patronus

[global]
listen-addr = {}
port = 1701

[lns default]
ip range = {}
local ip = {}
require chap = {}
refuse pap = yes
require authentication = yes
name = L2TP-Server
ppp debug = yes
pppoptfile = /etc/ppp/options.xl2tpd
length bit = yes
"#,
            self.config.listen_address,
            self.config.remote_ip_range,
            self.config.local_ip,
            if self.config.require_chap { "yes" } else { "no" }
        );

        tokio::fs::create_dir_all("/etc/xl2tpd").await?;
        tokio::fs::write("/etc/xl2tpd/xl2tpd.conf", xl2tpd_conf).await?;

        Ok(())
    }

    async fn configure_ppp(&self) -> Result<()> {
        // PPP options for xl2tpd
        let mut ppp_options = format!(r#"# PPP options for xl2tpd
# Generated by Patronus

ipcp-accept-local
ipcp-accept-remote
ms-dns {}
"#,
            self.config.dns_servers.get(0)
                .map(|ip| ip.to_string())
                .unwrap_or_else(|| "8.8.8.8".to_string())
        );

        if let Some(dns2) = self.config.dns_servers.get(1) {
            ppp_options.push_str(&format!("ms-dns {}\n", dns2));
        }

        if !self.config.wins_servers.is_empty() {
            for wins in &self.config.wins_servers {
                ppp_options.push_str(&format!("ms-wins {}\n", wins));
            }
        }

        ppp_options.push_str(&format!("\nnoccp\nauth\ncrtscts\nidle 1800\nmtu {}\nmru {}\n",
            self.config.mtu, self.config.mru));

        ppp_options.push_str("nodefaultroute\ndebug\nlock\nproxyarp\n");
        ppp_options.push_str("connect-delay 5000\n");

        // Authentication methods
        if self.config.require_mschapv2 {
            ppp_options.push_str("require-mschap-v2\n");
        } else if self.config.require_mschap {
            ppp_options.push_str("require-mschap\n");
        } else if self.config.require_chap {
            ppp_options.push_str("require-chap\n");
        }

        if self.config.require_encryption {
            ppp_options.push_str("require-mppe-128\n");
        }

        // LCP echo
        ppp_options.push_str(&format!("lcp-echo-interval {}\n", self.config.lcp_echo_interval));
        ppp_options.push_str(&format!("lcp-echo-failure {}\n", self.config.lcp_echo_failure));

        tokio::fs::create_dir_all("/etc/ppp").await?;
        tokio::fs::write("/etc/ppp/options.xl2tpd", ppp_options).await?;

        Ok(())
    }

    async fn create_user_secrets(&self) -> Result<()> {
        // Create chap-secrets file for user authentication
        let mut secrets = String::from("# L2TP User Secrets\n# Generated by Patronus\n\n");

        for user in &self.config.users {
            if !user.enabled {
                continue;
            }

            secrets.push_str(&format!("\"{}\" * \"{}\" ",
                user.username, user.password));

            if let Some(ip) = user.static_ip {
                secrets.push_str(&ip.to_string());
            } else {
                secrets.push('*');
            }

            secrets.push('\n');
        }

        tokio::fs::write("/etc/ppp/chap-secrets", secrets).await?;

        // Set restrictive permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata("/etc/ppp/chap-secrets").await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            tokio::fs::set_permissions("/etc/ppp/chap-secrets", perms).await?;
        }

        Ok(())
    }

    async fn create_systemd_services(&self) -> Result<()> {
        // xl2tpd service
        let xl2tpd_service = r#"[Unit]
Description=Layer 2 Tunneling Protocol Daemon
After=network.target ipsec.service
Requires=ipsec.service

[Service]
Type=simple
ExecStart=/usr/sbin/xl2tpd -D
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
"#;

        tokio::fs::write("/etc/systemd/system/xl2tpd.service", xl2tpd_service).await?;

        Ok(())
    }

    /// Start L2TP server
    pub async fn start(&self) -> Result<()> {
        tracing::info!("Starting L2TP/IPsec VPN server");

        // Start IPsec first
        let ipsec_status = Command::new("systemctl")
            .args(&["start", "ipsec"])
            .status()
            .await?;

        if !ipsec_status.success() {
            return Err(Error::Network("Failed to start IPsec".to_string()));
        }

        // Then start xl2tpd
        let xl2tpd_status = Command::new("systemctl")
            .args(&["start", "xl2tpd"])
            .status()
            .await?;

        if !xl2tpd_status.success() {
            return Err(Error::Network("Failed to start xl2tpd".to_string()));
        }

        Ok(())
    }

    /// Stop L2TP server
    pub async fn stop(&self) -> Result<()> {
        Command::new("systemctl")
            .args(&["stop", "xl2tpd"])
            .status()
            .await?;

        Command::new("systemctl")
            .args(&["stop", "ipsec"])
            .status()
            .await?;

        Ok(())
    }

    /// Get active L2TP connections
    pub async fn get_connections(&self) -> Result<Vec<L2tpConnection>> {
        let mut connections = Vec::new();

        // Query xl2tpd control socket
        // Simplified - would parse actual control socket in production
        let output = Command::new("xl2tpd-control")
            .arg("status")
            .output()
            .await;

        if let Ok(out) = output {
            let output_str = String::from_utf8_lossy(&out.stdout);
            // Parse connections from output
            tracing::debug!("L2TP connections: {}", output_str);
        }

        Ok(connections)
    }

    /// Disconnect a user
    pub async fn disconnect_user(&self, username: &str) -> Result<()> {
        tracing::info!("Disconnecting L2TP user: {}", username);

        // Send disconnect command
        // xl2tpd-control disconnect <tunnel_id> <session_id>

        Ok(())
    }

    /// Add user
    pub fn add_user(&mut self, user: L2tpUser) -> Result<()> {
        self.config.users.push(user);
        Ok(())
    }

    /// Remove user
    pub fn remove_user(&mut self, username: &str) -> Result<()> {
        self.config.users.retain(|u| u.username != username);
        Ok(())
    }

    /// Get statistics
    pub async fn get_stats(&self) -> Result<L2tpStats> {
        Ok(L2tpStats {
            total_connections: 0,
            active_connections: 0,
            total_bytes_sent: 0,
            total_bytes_received: 0,
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2tpStats {
    pub total_connections: u64,
    pub active_connections: u32,
    pub total_bytes_sent: u64,
    pub total_bytes_received: u64,
}

impl Default for L2tpConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            listen_address: "0.0.0.0".parse().unwrap(),
            local_ip: "10.2.0.1".parse().unwrap(),
            remote_ip_range: "10.2.0.2-10.2.0.254".to_string(),
            preshared_key: "changeme".to_string(),
            auth_type: L2tpAuthType::MSCHAPv2,
            require_chap: false,
            require_mschap: false,
            require_mschapv2: true,
            users: vec![],
            radius_auth: false,
            radius_server: None,
            radius_secret: None,
            dns_servers: vec![
                "8.8.8.8".parse().unwrap(),
                "8.8.4.4".parse().unwrap(),
            ],
            wins_servers: vec![],
            mtu: 1400,
            mru: 1400,
            lcp_echo_interval: 30,
            lcp_echo_failure: 4,
            require_encryption: true,
        }
    }
}
