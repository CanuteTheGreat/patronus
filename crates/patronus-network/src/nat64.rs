//! NAT64/DNS64 - IPv6 Transition Mechanism
//!
//! Enables IPv6-only clients to access IPv4-only servers by:
//! - NAT64: Translates IPv6 packets to IPv4 at network layer
//! - DNS64: Generates synthetic AAAA records from A records
//! - 464XLAT/CLAT: Client-side translation for legacy apps
//!
//! Essential for IPv6-only networks (ISPs, data centers, mobile carriers).

use patronus_core::{Result, Error};
use serde::{Deserialize, Serialize};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use std::path::PathBuf;
use tokio::process::Command;

/// NAT64 configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Nat64Config {
    pub enabled: bool,
    pub prefix: Ipv6Addr,           // Usually 64:ff9b::/96 (well-known prefix)
    pub prefix_len: u8,             // Usually 96
    pub pool_v4_start: Ipv4Addr,    // IPv4 address pool start
    pub pool_v4_end: Ipv4Addr,      // IPv4 address pool end
    pub dynamic_pool: bool,          // Dynamic vs static mapping
    pub nat64_interface: String,     // Interface for NAT64 (WAN)
    pub dns64_enabled: bool,         // Enable DNS64 in Unbound
    pub dns64_prefix: String,        // DNS64 prefix (usually same as NAT64)
    pub clat_support: bool,          // Enable CLAT announcements
}

/// DNS64 configuration for Unbound
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dns64Config {
    pub enabled: bool,
    pub prefix: String,              // e.g., "64:ff9b::/96"
    pub ignore_aaaa: Vec<String>,    // Don't synthesize for these domains
    pub exclude_networks: Vec<String>, // Don't use DNS64 for these IPv4 ranges
}

/// NAT64 statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Nat64Stats {
    pub v6_to_v4_packets: u64,
    pub v4_to_v6_packets: u64,
    pub active_sessions: u64,
    pub pool_utilization: f32,       // Percentage of IPv4 pool used
}

pub struct Nat64Manager {
    config: Nat64Config,
    tayga_conf_path: PathBuf,
}

impl Nat64Manager {
    pub fn new(config: Nat64Config) -> Self {
        Self {
            config,
            tayga_conf_path: PathBuf::from("/etc/tayga.conf"),
        }
    }

    /// Start NAT64 service
    pub async fn start(&self) -> Result<()> {
        if !self.config.enabled {
            return Ok(());
        }

        tracing::info!("Starting NAT64/DNS64 service");

        // Generate tayga configuration
        self.generate_tayga_config().await?;

        // Create TUN interface for tayga
        self.setup_tun_interface().await?;

        // Configure DNS64 in Unbound
        if self.config.dns64_enabled {
            self.configure_dns64().await?;
        }

        // Start tayga daemon
        self.start_tayga().await?;

        // Configure routing
        self.configure_routing().await?;

        // Configure PREF64 announcements if CLAT support
        if self.config.clat_support {
            self.configure_pref64().await?;
        }

        tracing::info!("NAT64/DNS64 service started successfully");

        Ok(())
    }

    /// Stop NAT64 service
    pub async fn stop(&self) -> Result<()> {
        tracing::info!("Stopping NAT64/DNS64 service");

        // Stop tayga
        Command::new("systemctl")
            .args(&["stop", "tayga"])
            .status()
            .await?;

        // Remove DNS64 configuration
        if self.config.dns64_enabled {
            self.remove_dns64_config().await?;
        }

        Ok(())
    }

    async fn generate_tayga_config(&self) -> Result<()> {
        let mut config = String::from("# Tayga NAT64 Configuration\n");
        config.push_str("# Generated by Patronus\n\n");

        // TUN device
        config.push_str("tun-device nat64\n");

        // IPv4 pool
        config.push_str(&format!("ipv4-addr {}\n",
            self.calculate_tayga_ipv4_addr()?));

        // NAT64 prefix
        config.push_str(&format!("prefix {}/{}\n",
            self.config.prefix, self.config.prefix_len));

        // Dynamic pool
        if self.config.dynamic_pool {
            config.push_str(&format!("dynamic-pool {}-{}\n",
                self.config.pool_v4_start, self.config.pool_v4_end));
        }

        // Data directory
        config.push_str("data-dir /var/lib/tayga\n");

        // Write configuration
        tokio::fs::write(&self.tayga_conf_path, config).await?;

        Ok(())
    }

    fn calculate_tayga_ipv4_addr(&self) -> Result<Ipv4Addr> {
        // Use first address in pool for tayga itself
        Ok(self.config.pool_v4_start)
    }

    async fn setup_tun_interface(&self) -> Result<()> {
        // Create data directory
        tokio::fs::create_dir_all("/var/lib/tayga").await?;

        // Setup TUN device (tayga will create it)
        // But we can pre-create it for better control
        Command::new("ip")
            .args(&["tuntap", "add", "dev", "nat64", "mode", "tun"])
            .status()
            .await
            .ok(); // May fail if already exists

        // Bring interface up
        Command::new("ip")
            .args(&["link", "set", "nat64", "up"])
            .status()
            .await?;

        Ok(())
    }

    async fn configure_dns64(&self) -> Result<()> {
        let dns64_config = self.generate_dns64_config();

        // Write DNS64 configuration to Unbound include file
        let dns64_path = PathBuf::from("/etc/unbound/unbound.conf.d/dns64.conf");

        tokio::fs::create_dir_all(dns64_path.parent().unwrap()).await?;
        tokio::fs::write(&dns64_path, dns64_config).await?;

        // Reload Unbound
        Command::new("systemctl")
            .args(&["reload", "unbound"])
            .status()
            .await?;

        tracing::info!("DNS64 configured in Unbound");

        Ok(())
    }

    fn generate_dns64_config(&self) -> String {
        let mut config = String::from("# DNS64 Configuration\n");
        config.push_str("# Generated by Patronus\n\n");

        config.push_str("server:\n");
        config.push_str("    # Enable DNS64\n");
        config.push_str(&format!("    module-config: \"dns64 validator iterator\"\n\n"));

        config.push_str("dns64:\n");
        config.push_str(&format!("    dns64-prefix: {}\n", self.config.dns64_prefix));

        // Ignore AAAA for specific domains
        if !self.config.dns64_prefix.is_empty() {
            config.push_str("    # Don't synthesize AAAA for these domains\n");
            // Example: ignore native IPv6 domains
            config.push_str("    dns64-ignore-aaaa: \"ipv6.google.com\"\n");
        }

        config
    }

    async fn remove_dns64_config(&self) -> Result<()> {
        let dns64_path = PathBuf::from("/etc/unbound/unbound.conf.d/dns64.conf");

        if dns64_path.exists() {
            tokio::fs::remove_file(&dns64_path).await?;

            // Reload Unbound
            Command::new("systemctl")
                .args(&["reload", "unbound"])
                .status()
                .await?;
        }

        Ok(())
    }

    async fn start_tayga(&self) -> Result<()> {
        // Create systemd service if doesn't exist
        self.create_tayga_service().await?;

        // Start tayga
        let status = Command::new("systemctl")
            .args(&["start", "tayga"])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to start tayga".to_string()));
        }

        // Enable at boot
        Command::new("systemctl")
            .args(&["enable", "tayga"])
            .status()
            .await?;

        Ok(())
    }

    async fn create_tayga_service(&self) -> Result<()> {
        let service = r#"[Unit]
Description=Tayga NAT64 Gateway
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/tayga -d
ExecStop=/usr/bin/killall tayga
Restart=on-failure

[Install]
WantedBy=multi-user.target
"#;

        let service_path = PathBuf::from("/etc/systemd/system/tayga.service");
        tokio::fs::write(&service_path, service).await?;

        // Reload systemd
        Command::new("systemctl")
            .args(&["daemon-reload"])
            .status()
            .await?;

        Ok(())
    }

    async fn configure_routing(&self) -> Result<()> {
        // Add route for NAT64 prefix through nat64 interface
        Command::new("ip")
            .args(&[
                "-6", "route", "add",
                &format!("{}/{}", self.config.prefix, self.config.prefix_len),
                "dev", "nat64"
            ])
            .status()
            .await?;

        // Enable IPv4 forwarding (required for NAT64)
        tokio::fs::write("/proc/sys/net/ipv4/ip_forward", "1").await?;

        // Enable IPv6 forwarding
        tokio::fs::write("/proc/sys/net/ipv6/conf/all/forwarding", "1").await?;

        // Configure NAT for IPv4 pool on WAN interface
        Command::new("nft")
            .args(&[
                "add", "rule", "inet", "patronus", "postrouting",
                "oifname", &self.config.nat64_interface,
                "ip", "saddr", &format!("{}-{}",
                    self.config.pool_v4_start, self.config.pool_v4_end),
                "masquerade"
            ])
            .status()
            .await?;

        Ok(())
    }

    async fn configure_pref64(&self) -> Result<()> {
        // Configure PREF64 in radvd for CLAT support
        // PREF64 option allows clients to discover NAT64 prefix automatically

        let radvd_config = format!(r#"
# PREF64 for NAT64 prefix discovery (RFC 8781)
interface {interface} {{
    AdvSendAdvert on;

    # NAT64 prefix (PREF64 option)
    PREF64 {prefix}/{prefix_len} {{
        AdvPreferredLifetime 300;
        AdvValidLifetime 300;
    }};
}};
"#,
            interface = self.config.nat64_interface,
            prefix = self.config.prefix,
            prefix_len = self.config.prefix_len
        );

        // Append to radvd config or create separate file
        let pref64_path = PathBuf::from("/etc/radvd.d/nat64-pref64.conf");
        tokio::fs::create_dir_all(pref64_path.parent().unwrap()).await?;
        tokio::fs::write(&pref64_path, radvd_config).await?;

        // Reload radvd if running
        Command::new("systemctl")
            .args(&["reload-or-restart", "radvd"])
            .status()
            .await
            .ok(); // May not be running, that's OK

        tracing::info!("PREF64 configured for NAT64 prefix discovery");

        Ok(())
    }

    /// Get NAT64 statistics
    pub async fn get_stats(&self) -> Result<Nat64Stats> {
        // Parse tayga statistics
        let stats_output = Command::new("tayga")
            .args(&["--stats"])
            .output()
            .await;

        if let Ok(output) = stats_output {
            let stdout = String::from_utf8_lossy(&output.stdout);

            // Parse statistics (example format)
            let stats = Nat64Stats {
                v6_to_v4_packets: self.parse_stat(&stdout, "IPv6 to IPv4").unwrap_or(0),
                v4_to_v6_packets: self.parse_stat(&stdout, "IPv4 to IPv6").unwrap_or(0),
                active_sessions: self.get_active_sessions().await.unwrap_or(0),
                pool_utilization: self.calculate_pool_utilization().await.unwrap_or(0.0),
            };

            Ok(stats)
        } else {
            Ok(Nat64Stats {
                v6_to_v4_packets: 0,
                v4_to_v6_packets: 0,
                active_sessions: 0,
                pool_utilization: 0.0,
            })
        }
    }

    fn parse_stat(&self, output: &str, key: &str) -> Option<u64> {
        output.lines()
            .find(|line| line.contains(key))
            .and_then(|line| line.split_whitespace().last())
            .and_then(|s| s.parse().ok())
    }

    async fn get_active_sessions(&self) -> Result<u64> {
        // Count active NAT64 sessions from tayga state
        let state_file = PathBuf::from("/var/lib/tayga/dynamic.map");

        if state_file.exists() {
            let content = tokio::fs::read_to_string(&state_file).await?;
            Ok(content.lines().count() as u64)
        } else {
            Ok(0)
        }
    }

    async fn calculate_pool_utilization(&self) -> Result<f32> {
        let active = self.get_active_sessions().await?;
        let total = self.calculate_pool_size()?;

        Ok((active as f32 / total as f32) * 100.0)
    }

    fn calculate_pool_size(&self) -> Result<u32> {
        // Calculate number of addresses in pool
        let start: u32 = self.config.pool_v4_start.into();
        let end: u32 = self.config.pool_v4_end.into();
        Ok(end - start + 1)
    }

    /// Add static NAT64 mapping
    pub async fn add_static_mapping(&self, ipv6: Ipv6Addr, ipv4: Ipv4Addr) -> Result<()> {
        // Add to tayga static mappings
        let mapping = format!("{} {}\n", ipv6, ipv4);

        let map_file = PathBuf::from("/var/lib/tayga/static.map");

        // Append to static map file
        use tokio::io::AsyncWriteExt;
        let mut file = tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&map_file)
            .await?;

        file.write_all(mapping.as_bytes()).await?;

        // Reload tayga
        Command::new("systemctl")
            .args(&["reload", "tayga"])
            .status()
            .await?;

        Ok(())
    }

    /// Remove static NAT64 mapping
    pub async fn remove_static_mapping(&self, ipv6: Ipv6Addr) -> Result<()> {
        let map_file = PathBuf::from("/var/lib/tayga/static.map");

        if map_file.exists() {
            let content = tokio::fs::read_to_string(&map_file).await?;
            let filtered: String = content.lines()
                .filter(|line| !line.starts_with(&ipv6.to_string()))
                .map(|line| format!("{}\n", line))
                .collect();

            tokio::fs::write(&map_file, filtered).await?;

            // Reload tayga
            Command::new("systemctl")
                .args(&["reload", "tayga"])
                .status()
                .await?;
        }

        Ok(())
    }

    /// Validate NAT64 configuration
    pub fn validate(&self) -> Result<()> {
        // Check prefix length
        if self.config.prefix_len != 96 && self.config.prefix_len != 64 {
            return Err(Error::Config(
                "NAT64 prefix length must be 96 or 64".to_string()
            ));
        }

        // Check pool is valid
        let start: u32 = self.config.pool_v4_start.into();
        let end: u32 = self.config.pool_v4_end.into();

        if start >= end {
            return Err(Error::Config(
                "IPv4 pool start must be less than end".to_string()
            ));
        }

        // Check pool size is reasonable
        let pool_size = end - start + 1;
        if pool_size > 65536 {
            return Err(Error::Config(
                "IPv4 pool too large (max 65536 addresses)".to_string()
            ));
        }

        Ok(())
    }
}

impl Default for Nat64Config {
    fn default() -> Self {
        Self {
            enabled: false,
            prefix: "64:ff9b::".parse().unwrap(),  // Well-known NAT64 prefix
            prefix_len: 96,
            pool_v4_start: "192.0.2.1".parse().unwrap(),
            pool_v4_end: "192.0.2.254".parse().unwrap(),
            dynamic_pool: true,
            nat64_interface: "wan0".to_string(),
            dns64_enabled: true,
            dns64_prefix: "64:ff9b::/96".to_string(),
            clat_support: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pool_size_calculation() {
        let config = Nat64Config {
            pool_v4_start: "192.0.2.1".parse().unwrap(),
            pool_v4_end: "192.0.2.254".parse().unwrap(),
            ..Default::default()
        };

        let manager = Nat64Manager::new(config);
        assert_eq!(manager.calculate_pool_size().unwrap(), 254);
    }

    #[test]
    fn test_validation() {
        let config = Nat64Config::default();
        let manager = Nat64Manager::new(config);
        assert!(manager.validate().is_ok());
    }

    #[test]
    fn test_invalid_prefix_length() {
        let config = Nat64Config {
            prefix_len: 48,  // Invalid
            ..Default::default()
        };

        let manager = Nat64Manager::new(config);
        assert!(manager.validate().is_err());
    }
}
