//! PPPoE (Point-to-Point Protocol over Ethernet)
//!
//! Provides PPPoE client and server functionality for DSL connections.
//! Essential for ISP connections and DSL modems.

use patronus_core::{Result, Error};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use tokio::process::Command;
use std::net::IpAddr;

/// PPPoE configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PppoeConfig {
    pub enabled: bool,
    pub mode: PppoeMode,
    pub interface: String,  // Physical interface (eth0, etc.)

    // Client settings
    pub username: String,
    pub password: String,
    pub service_name: Option<String>,
    pub ac_name: Option<String>,  // Access Concentrator name

    // Connection settings
    pub on_demand: bool,
    pub idle_timeout: u32,  // Seconds
    pub persist: bool,
    pub max_fail: u32,

    // Authentication
    pub auth_method: PppAuthMethod,
    pub refuse_pap: bool,
    pub refuse_chap: bool,

    // Network settings
    pub mtu: u16,
    pub mru: u16,
    pub default_route: bool,
    pub replace_default_route: bool,
    pub use_peer_dns: bool,

    // Advanced
    pub lcp_echo_interval: u32,
    pub lcp_echo_failure: u32,
    pub connect_timeout: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PppoeMode {
    Client,
    Server,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PppAuthMethod {
    PAP,
    CHAP,
    MSCHAP,
    MSCHAPv2,
    EAP,
}

/// PPPoE server configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PppoeServerConfig {
    pub enabled: bool,
    pub interface: String,
    pub service_name: String,
    pub local_ip: IpAddr,
    pub remote_ip_range: String,  // "192.168.100.10-192.168.100.50"
    pub dns_servers: Vec<IpAddr>,
    pub auth_file: PathBuf,  // /etc/ppp/pppoe-server-options
    pub max_sessions: u32,
}

/// PPPoE connection status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PppoeStatus {
    pub connected: bool,
    pub interface: String,  // ppp0
    pub local_ip: Option<IpAddr>,
    pub remote_ip: Option<IpAddr>,
    pub dns_servers: Vec<IpAddr>,
    pub uptime_seconds: u64,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

pub struct PppoeManager {
    config: PppoeConfig,
    config_dir: PathBuf,
}

impl PppoeManager {
    pub fn new(config: PppoeConfig) -> Self {
        Self {
            config,
            config_dir: PathBuf::from("/etc/ppp"),
        }
    }

    /// Configure PPPoE client
    pub async fn configure_client(&self) -> Result<()> {
        // Create PPP configuration files
        self.create_ppp_options().await?;
        self.create_pap_secrets().await?;
        self.create_chap_secrets().await?;

        // Create systemd service or OpenRC init script
        self.create_service_file().await?;

        Ok(())
    }

    async fn create_ppp_options(&self) -> Result<()> {
        let options = format!(r#"# PPPoE configuration for {}
# Generated by Patronus

# Plugin
plugin rp-pppoe.so

# Interface
nic-{}

# User
user "{}"

# Connection settings
persist
maxfail {}
holdoff 5

# LCP settings
lcp-echo-interval {}
lcp-echo-failure {}

# Authentication
{}
{}

# Network settings
defaultroute
{}
noipdefault
noauth

# MTU/MRU
mtu {}
mru {}

# DNS
{}

# Logging
debug
logfile /var/log/ppp/pppoe.log
"#,
            self.config.interface,
            self.config.interface,
            self.config.username,
            self.config.max_fail,
            self.config.lcp_echo_interval,
            self.config.lcp_echo_failure,
            if self.config.refuse_pap { "refuse-pap" } else { "" },
            if self.config.refuse_chap { "refuse-chap" } else { "" },
            if self.config.replace_default_route { "replacedefaultroute" } else { "" },
            self.config.mtu,
            self.config.mru,
            if self.config.use_peer_dns { "usepeerdns" } else { "" },
        );

        let options_file = self.config_dir.join("options");
        tokio::fs::write(options_file, options).await?;

        Ok(())
    }

    async fn create_pap_secrets(&self) -> Result<()> {
        let secrets = format!(r#"# PAP secrets
# Generated by Patronus

"{}" * "{}"
"#,
            self.config.username,
            self.config.password,
        );

        let secrets_file = self.config_dir.join("pap-secrets");
        tokio::fs::write(&secrets_file, secrets).await?;

        // Set restrictive permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata(&secrets_file).await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            tokio::fs::set_permissions(&secrets_file, perms).await?;
        }

        Ok(())
    }

    async fn create_chap_secrets(&self) -> Result<()> {
        let secrets = format!(r#"# CHAP secrets
# Generated by Patronus

"{}" * "{}"
"#,
            self.config.username,
            self.config.password,
        );

        let secrets_file = self.config_dir.join("chap-secrets");
        tokio::fs::write(&secrets_file, secrets).await?;

        // Set restrictive permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata(&secrets_file).await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            tokio::fs::set_permissions(&secrets_file, perms).await?;
        }

        Ok(())
    }

    async fn create_service_file(&self) -> Result<()> {
        // systemd service
        let service = format!(r#"[Unit]
Description=PPPoE connection for {}
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call provider
ExecStop=/usr/bin/killall pppd
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
"#,
            self.config.interface
        );

        tokio::fs::write("/etc/systemd/system/pppoe.service", service).await?;

        // OpenRC init script
        let initd = format!(r#"#!/sbin/openrc-run
# PPPoE connection

description="PPPoE connection for {}"

depend() {{
    need net
    before firewall
}}

start() {{
    ebegin "Starting PPPoE connection"
    /usr/sbin/pppd call provider
    eend $?
}}

stop() {{
    ebegin "Stopping PPPoE connection"
    killall pppd
    eend $?
}}
"#,
            self.config.interface
        );

        tokio::fs::write("/etc/init.d/pppoe", initd).await?;

        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata("/etc/init.d/pppoe").await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o755);
            tokio::fs::set_permissions("/etc/init.d/pppoe", perms).await?;
        }

        Ok(())
    }

    /// Start PPPoE connection
    pub async fn connect(&self) -> Result<()> {
        tracing::info!("Starting PPPoE connection on {}", self.config.interface);

        let status = Command::new("pppd")
            .arg("call")
            .arg("provider")
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to start PPPoE connection".to_string()));
        }

        Ok(())
    }

    /// Stop PPPoE connection
    pub async fn disconnect(&self) -> Result<()> {
        tracing::info!("Stopping PPPoE connection");

        Command::new("killall")
            .arg("pppd")
            .status()
            .await?;

        Ok(())
    }

    /// Get connection status
    pub async fn get_status(&self) -> Result<PppoeStatus> {
        // Check if pppd is running
        let output = Command::new("pgrep")
            .arg("pppd")
            .output()
            .await?;

        let connected = output.status.success();

        if !connected {
            return Ok(PppoeStatus {
                connected: false,
                interface: "ppp0".to_string(),
                local_ip: None,
                remote_ip: None,
                dns_servers: vec![],
                uptime_seconds: 0,
                bytes_sent: 0,
                bytes_received: 0,
            });
        }

        // Parse ifconfig output for ppp0
        let output = Command::new("ip")
            .args(&["addr", "show", "ppp0"])
            .output()
            .await?;

        let output_str = String::from_utf8_lossy(&output.stdout);

        // Extract IP addresses (simplified parsing)
        let local_ip = self.parse_ip_from_output(&output_str);

        Ok(PppoeStatus {
            connected: true,
            interface: "ppp0".to_string(),
            local_ip,
            remote_ip: None,
            dns_servers: vec![],
            uptime_seconds: 0,
            bytes_sent: 0,
            bytes_received: 0,
        })
    }

    fn parse_ip_from_output(&self, output: &str) -> Option<IpAddr> {
        // Simple IP parsing - would be more robust in production
        for line in output.lines() {
            if line.contains("inet ") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() > 1 {
                    if let Ok(ip) = parts[1].split('/').next().unwrap_or("").parse() {
                        return Some(ip);
                    }
                }
            }
        }
        None
    }

    /// Configure PPPoE server
    pub async fn configure_server(&self, server_config: &PppoeServerConfig) -> Result<()> {
        tracing::info!("Configuring PPPoE server on {}", server_config.interface);

        // Create pppoe-server configuration
        let config = format!(r#"# PPPoE Server Configuration
# Generated by Patronus

# Interface
INTERFACE={}

# Service name
SERVICE_NAME={}

# IP addresses
LOCAL_IP={}
REMOTE_IP={}

# Options file
PPPOE_OPTIONS=/etc/ppp/pppoe-server-options

# Max sessions
MAX_SESSIONS={}
"#,
            server_config.interface,
            server_config.service_name,
            server_config.local_ip,
            server_config.remote_ip_range,
            server_config.max_sessions,
        );

        tokio::fs::write("/etc/pppoe-server.conf", config).await?;

        // Create PPP options for server
        let ppp_options = format!(r#"# PPPoE Server PPP Options

require-chap
login
lcp-echo-interval 30
lcp-echo-failure 4
ms-dns {}
ms-dns {}
netmask 255.255.255.0
proxyarp
"#,
            server_config.dns_servers.get(0).map(|ip| ip.to_string()).unwrap_or_else(|| "8.8.8.8".to_string()),
            server_config.dns_servers.get(1).map(|ip| ip.to_string()).unwrap_or_else(|| "8.8.4.4".to_string()),
        );

        tokio::fs::write(&server_config.auth_file, ppp_options).await?;

        Ok(())
    }

    /// Start PPPoE server
    pub async fn start_server(&self, server_config: &PppoeServerConfig) -> Result<()> {
        let status = Command::new("pppoe-server")
            .args(&[
                "-I", &server_config.interface,
                "-L", &server_config.local_ip.to_string(),
                "-R", &server_config.remote_ip_range,
                "-N", &server_config.max_sessions.to_string(),
            ])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to start PPPoE server".to_string()));
        }

        Ok(())
    }

    /// Get active PPPoE server sessions
    pub async fn get_server_sessions(&self) -> Result<Vec<PppoeSession>> {
        // Parse active sessions from pppd
        Ok(vec![])
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PppoeSession {
    pub username: String,
    pub interface: String,
    pub ip_address: IpAddr,
    pub connected_at: chrono::DateTime<chrono::Utc>,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

impl Default for PppoeConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            mode: PppoeMode::Client,
            interface: "eth0".to_string(),
            username: "user@isp.com".to_string(),
            password: "password".to_string(),
            service_name: None,
            ac_name: None,
            on_demand: false,
            idle_timeout: 300,
            persist: true,
            max_fail: 3,
            auth_method: PppAuthMethod::PAP,
            refuse_pap: false,
            refuse_chap: false,
            mtu: 1492,  // Standard for PPPoE
            mru: 1492,
            default_route: true,
            replace_default_route: true,
            use_peer_dns: true,
            lcp_echo_interval: 30,
            lcp_echo_failure: 4,
            connect_timeout: 30,
        }
    }
}

impl Default for PppoeServerConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            interface: "eth0".to_string(),
            service_name: "patronus-pppoe".to_string(),
            local_ip: "192.168.100.1".parse().unwrap(),
            remote_ip_range: "192.168.100.10-192.168.100.50".to_string(),
            dns_servers: vec![
                "8.8.8.8".parse().unwrap(),
                "8.8.4.4".parse().unwrap(),
            ],
            auth_file: PathBuf::from("/etc/ppp/pppoe-server-options"),
            max_sessions: 50,
        }
    }
}
