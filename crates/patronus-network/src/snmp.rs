//! SNMP Agent (Simple Network Management Protocol)
//!
//! Provides SNMP v2c and v3 agent functionality for network monitoring integration.
//! Allows monitoring systems (Zabbix, Nagios, PRTG, etc.) to query firewall status.

use patronus_core::{Result, Error};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use tokio::process::Command;

/// SNMP version
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SnmpVersion {
    V2c,  // Community-based (simple but less secure)
    V3,   // User-based (secure with auth & encryption)
}

/// SNMP v3 security level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SnmpSecurityLevel {
    NoAuthNoPriv,    // No authentication, no encryption
    AuthNoPriv,      // Authentication, no encryption
    AuthPriv,        // Authentication and encryption
}

/// SNMP v3 authentication protocol
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SnmpAuthProtocol {
    MD5,
    SHA,
    SHA224,
    SHA256,
    SHA384,
    SHA512,
}

/// SNMP v3 privacy (encryption) protocol
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SnmpPrivProtocol {
    DES,
    AES,
    AES192,
    AES256,
}

/// SNMP v2c configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpV2Config {
    pub enabled: bool,
    pub community: String,           // Community string (password)
    pub read_only: bool,             // Read-only or read-write
    pub allowed_hosts: Vec<String>,  // IP/CIDR allowed to query
}

/// SNMP v3 user configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpV3User {
    pub username: String,
    pub security_level: SnmpSecurityLevel,

    // Authentication
    pub auth_protocol: Option<SnmpAuthProtocol>,
    pub auth_password: Option<String>,

    // Privacy (encryption)
    pub priv_protocol: Option<SnmpPrivProtocol>,
    pub priv_password: Option<String>,
}

/// SNMP v3 configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpV3Config {
    pub enabled: bool,
    pub users: Vec<SnmpV3User>,
    pub allowed_hosts: Vec<String>,
}

/// SNMP agent configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpConfig {
    pub enabled: bool,
    pub version: SnmpVersion,

    // Listening
    pub bind_address: IpAddr,
    pub port: u16,  // Default 161

    // System information
    pub sys_location: String,
    pub sys_contact: String,
    pub sys_name: String,
    pub sys_description: String,

    // Version-specific config
    pub v2c: SnmpV2Config,
    pub v3: SnmpV3Config,

    // Traps (notifications)
    pub trap_enabled: bool,
    pub trap_community: String,
    pub trap_destinations: Vec<SnmpTrapDestination>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpTrapDestination {
    pub address: IpAddr,
    pub port: u16,  // Default 162
    pub community: String,
}

/// SNMP statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpStats {
    pub packets_received: u64,
    pub packets_sent: u64,
    pub get_requests: u64,
    pub get_next_requests: u64,
    pub set_requests: u64,
    pub traps_sent: u64,
    pub errors: u64,
}

pub struct SnmpManager {
    config: SnmpConfig,
}

impl SnmpManager {
    pub fn new(config: SnmpConfig) -> Self {
        Self { config }
    }

    /// Configure SNMP agent (using Net-SNMP)
    pub async fn configure(&self) -> Result<()> {
        tracing::info!("Configuring SNMP agent");

        // Generate snmpd.conf
        let config_content = self.generate_snmpd_config();
        tokio::fs::write("/etc/snmp/snmpd.conf", config_content).await?;

        // Set restrictive permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata("/etc/snmp/snmpd.conf").await?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o600);
            tokio::fs::set_permissions("/etc/snmp/snmpd.conf", perms).await?;
        }

        // Create systemd service
        self.create_systemd_service().await?;

        Ok(())
    }

    fn generate_snmpd_config(&self) -> String {
        let mut config = String::from("# SNMP Agent Configuration\n");
        config.push_str("# Generated by Patronus\n\n");

        // System information
        config.push_str("# System Information\n");
        config.push_str(&format!("syslocation {}\n", self.config.sys_location));
        config.push_str(&format!("syscontact {}\n", self.config.sys_contact));
        config.push_str(&format!("sysname {}\n", self.config.sys_name));
        config.push_str(&format!("sysdescr {}\n\n", self.config.sys_description));

        // Listening address
        config.push_str(&format!("agentaddress udp:{}:{}\n\n",
            self.config.bind_address, self.config.port));

        // SNMP v2c configuration
        if self.config.v2c.enabled {
            config.push_str("# SNMP v2c Configuration\n");

            let access = if self.config.v2c.read_only { "rocommunity" } else { "rwcommunity" };

            if self.config.v2c.allowed_hosts.is_empty() {
                // Allow from anywhere (not recommended)
                config.push_str(&format!("{} {}\n", access, self.config.v2c.community));
            } else {
                // Restrict to specific hosts/networks
                for host in &self.config.v2c.allowed_hosts {
                    config.push_str(&format!("{} {} {}\n",
                        access, self.config.v2c.community, host));
                }
            }
            config.push_str("\n");
        }

        // SNMP v3 configuration
        if self.config.v3.enabled {
            config.push_str("# SNMP v3 Configuration\n");

            // Create users
            for user in &self.config.v3.users {
                config.push_str(&self.generate_v3_user_config(user));
            }

            // Access control
            config.push_str("# V3 Access Control\n");
            for user in &self.config.v3.users {
                config.push_str(&format!("rouser {}\n", user.username));
            }

            if !self.config.v3.allowed_hosts.is_empty() {
                for host in &self.config.v3.allowed_hosts {
                    config.push_str(&format!("# Restrict to: {}\n", host));
                }
            }
            config.push_str("\n");
        }

        // MIB support
        config.push_str("# MIB Support\n");
        config.push_str("view systemonly included .1.3.6.1.2.1.1\n");
        config.push_str("view systemonly included .1.3.6.1.2.1.25.1\n");
        config.push_str("view all included .1 80\n\n");

        // Disk monitoring
        config.push_str("# Disk Monitoring\n");
        config.push_str("disk / 10000\n");
        config.push_str("disk /var 5000\n\n");

        // Load monitoring
        config.push_str("# Load Monitoring\n");
        config.push_str("load 12 10 5\n\n");

        // Process monitoring
        config.push_str("# Process Monitoring\n");
        config.push_str("proc sshd\n");
        config.push_str("proc cron\n\n");

        // Extend with custom scripts
        config.push_str("# Extended Information\n");
        config.push_str("extend uptime /bin/uptime\n");
        config.push_str("extend interfaces /usr/bin/ip -s link\n\n");

        // Traps
        if self.config.trap_enabled {
            config.push_str("# SNMP Traps\n");
            for dest in &self.config.trap_destinations {
                config.push_str(&format!("trapsink {}:{} {}\n",
                    dest.address, dest.port, dest.community));
            }
            config.push_str("\n");
        }

        // Logging
        config.push_str("# Logging\n");
        config.push_str("logOption f /var/log/snmpd.log\n");

        config
    }

    fn generate_v3_user_config(&self, user: &SnmpV3User) -> String {
        let mut config = String::new();

        match user.security_level {
            SnmpSecurityLevel::NoAuthNoPriv => {
                config.push_str(&format!("createUser {} \n", user.username));
            }
            SnmpSecurityLevel::AuthNoPriv => {
                if let (Some(auth_proto), Some(auth_pass)) = (&user.auth_protocol, &user.auth_password) {
                    config.push_str(&format!("createUser {} {:?} {}\n",
                        user.username,
                        auth_proto,
                        auth_pass));
                }
            }
            SnmpSecurityLevel::AuthPriv => {
                if let (Some(auth_proto), Some(auth_pass), Some(priv_proto), Some(priv_pass)) =
                    (&user.auth_protocol, &user.auth_password, &user.priv_protocol, &user.priv_password) {
                    config.push_str(&format!("createUser {} {:?} {} {:?} {}\n",
                        user.username,
                        auth_proto,
                        auth_pass,
                        priv_proto,
                        priv_pass));
                }
            }
        }

        config
    }

    async fn create_systemd_service(&self) -> Result<()> {
        let service = r#"[Unit]
Description=Simple Network Management Protocol (SNMP) Daemon
After=network.target

[Service]
Type=notify
ExecStart=/usr/sbin/snmpd -Lf /var/log/snmpd.log -f
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure

[Install]
WantedBy=multi-user.target
"#;

        tokio::fs::write("/etc/systemd/system/snmpd.service", service).await?;

        Ok(())
    }

    /// Start SNMP agent
    pub async fn start(&self) -> Result<()> {
        tracing::info!("Starting SNMP agent");

        let status = Command::new("systemctl")
            .args(&["start", "snmpd"])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to start SNMP agent".to_string()));
        }

        Ok(())
    }

    /// Stop SNMP agent
    pub async fn stop(&self) -> Result<()> {
        Command::new("systemctl")
            .args(&["stop", "snmpd"])
            .status()
            .await?;

        Ok(())
    }

    /// Restart SNMP agent
    pub async fn restart(&self) -> Result<()> {
        let status = Command::new("systemctl")
            .args(&["restart", "snmpd"])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to restart SNMP agent".to_string()));
        }

        Ok(())
    }

    /// Get SNMP statistics
    pub async fn get_stats(&self) -> Result<SnmpStats> {
        // Query SNMP stats from agent
        let output = Command::new("snmpstatus")
            .args(&["-v", "2c", "-c", &self.config.v2c.community, "localhost"])
            .output()
            .await?;

        // Parse statistics (simplified)
        Ok(SnmpStats {
            packets_received: 0,
            packets_sent: 0,
            get_requests: 0,
            get_next_requests: 0,
            set_requests: 0,
            traps_sent: 0,
            errors: 0,
        })
    }

    /// Test SNMP agent
    pub async fn test(&self) -> Result<bool> {
        tracing::info!("Testing SNMP agent");

        let output = Command::new("snmpwalk")
            .args(&[
                "-v", "2c",
                "-c", &self.config.v2c.community,
                "localhost",
                "system"
            ])
            .output()
            .await?;

        Ok(output.status.success())
    }

    /// Send SNMP trap
    pub async fn send_trap(&self, oid: &str, value: &str) -> Result<()> {
        if !self.config.trap_enabled || self.config.trap_destinations.is_empty() {
            return Ok(());
        }

        for dest in &self.config.trap_destinations {
            let _output = Command::new("snmptrap")
                .args(&[
                    "-v", "2c",
                    "-c", &dest.community,
                    &format!("{}:{}", dest.address, dest.port),
                    "",  // Uptime
                    oid,
                    value,
                ])
                .output()
                .await?;
        }

        Ok(())
    }

    /// Get system information via SNMP
    pub async fn get_system_info(&self) -> Result<SnmpSystemInfo> {
        let output = Command::new("snmpget")
            .args(&[
                "-v", "2c",
                "-c", &self.config.v2c.community,
                "localhost",
                "sysDescr.0",
                "sysUpTime.0",
                "sysContact.0",
                "sysName.0",
                "sysLocation.0",
            ])
            .output()
            .await?;

        let output_str = String::from_utf8_lossy(&output.stdout);

        Ok(SnmpSystemInfo {
            description: self.config.sys_description.clone(),
            uptime: 0,
            contact: self.config.sys_contact.clone(),
            name: self.config.sys_name.clone(),
            location: self.config.sys_location.clone(),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnmpSystemInfo {
    pub description: String,
    pub uptime: u64,
    pub contact: String,
    pub name: String,
    pub location: String,
}

impl Default for SnmpConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            version: SnmpVersion::V2c,
            bind_address: "0.0.0.0".parse().unwrap(),
            port: 161,
            sys_location: "Server Room".to_string(),
            sys_contact: "admin@example.com".to_string(),
            sys_name: "patronus-firewall".to_string(),
            sys_description: "Patronus Firewall".to_string(),
            v2c: SnmpV2Config {
                enabled: true,
                community: "public".to_string(),
                read_only: true,
                allowed_hosts: vec![],
            },
            v3: SnmpV3Config {
                enabled: false,
                users: vec![],
                allowed_hosts: vec![],
            },
            trap_enabled: false,
            trap_community: "public".to_string(),
            trap_destinations: vec![],
        }
    }
}

impl Default for SnmpV3User {
    fn default() -> Self {
        Self {
            username: "snmpuser".to_string(),
            security_level: SnmpSecurityLevel::AuthPriv,
            auth_protocol: Some(SnmpAuthProtocol::SHA256),
            auth_password: Some("authpassword".to_string()),
            priv_protocol: Some(SnmpPrivProtocol::AES256),
            priv_password: Some("privpassword".to_string()),
        }
    }
}
