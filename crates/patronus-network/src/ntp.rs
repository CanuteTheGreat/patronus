//! NTP Server (Network Time Protocol)
//!
//! Provides time synchronization services using chrony.
//! Allows the firewall to act as an NTP server for the local network.

use patronus_core::{Result, Error};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use tokio::process::Command;

/// NTP server configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NtpConfig {
    pub enabled: bool,

    // Upstream NTP servers
    pub servers: Vec<NtpServer>,

    // Server mode (provide time to clients)
    pub server_mode: bool,
    pub allow_networks: Vec<String>,  // CIDR networks allowed to query

    // Time source preferences
    pub prefer_local_clock: bool,  // Use local clock as fallback
    pub stratum: u8,               // Local stratum level (if using local clock)

    // Advanced
    pub drift_file: String,
    pub log_dir: String,
    pub max_update_skew: f64,  // Maximum clock skew for updates (seconds)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NtpServer {
    pub address: String,  // Hostname or IP
    pub prefer: bool,     // Prefer this server
    pub iburst: bool,     // Send burst of packets at startup
    pub minpoll: u8,      // Minimum poll interval (2^n seconds)
    pub maxpoll: u8,      // Maximum poll interval (2^n seconds)
}

/// NTP status information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NtpStatus {
    pub synchronized: bool,
    pub stratum: u8,
    pub reference_id: String,
    pub offset: f64,          // Time offset in seconds
    pub jitter: f64,          // Time jitter in seconds
    pub current_source: Option<String>,
    pub sources: Vec<NtpSourceStatus>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NtpSourceStatus {
    pub address: String,
    pub stratum: u8,
    pub poll: u8,
    pub reach: u8,       // Reachability (octal)
    pub offset: f64,
    pub delay: f64,
    pub jitter: f64,
    pub selected: bool,
}

pub struct NtpManager {
    config: NtpConfig,
}

impl NtpManager {
    pub fn new(config: NtpConfig) -> Self {
        Self { config }
    }

    /// Configure chrony NTP server
    pub async fn configure(&self) -> Result<()> {
        tracing::info!("Configuring chrony NTP server");

        let config_content = self.generate_chrony_config();

        // Write chrony configuration
        tokio::fs::write("/etc/chrony/chrony.conf", config_content).await?;

        // Create systemd service (if not already exists)
        self.create_systemd_service().await?;

        Ok(())
    }

    fn generate_chrony_config(&self) -> String {
        let mut config = String::from("# Chrony Configuration\n");
        config.push_str("# Generated by Patronus\n\n");

        // Upstream servers
        config.push_str("# Upstream NTP servers\n");
        for server in &self.config.servers {
            let mut server_line = format!("server {}", server.address);

            if server.prefer {
                server_line.push_str(" prefer");
            }
            if server.iburst {
                server_line.push_str(" iburst");
            }
            if server.minpoll != 6 {  // Default is 6 (64 seconds)
                server_line.push_str(&format!(" minpoll {}", server.minpoll));
            }
            if server.maxpoll != 10 {  // Default is 10 (1024 seconds)
                server_line.push_str(&format!(" maxpoll {}", server.maxpoll));
            }

            server_line.push('\n');
            config.push_str(&server_line);
        }
        config.push('\n');

        // Server mode - allow clients to query
        if self.config.server_mode {
            config.push_str("# Allow NTP client access from local networks\n");
            for network in &self.config.allow_networks {
                config.push_str(&format!("allow {}\n", network));
            }
            config.push('\n');
        }

        // Drift file
        config.push_str(&format!("# Drift file\ndriftfile {}\n\n", self.config.drift_file));

        // Logging
        config.push_str(&format!("# Logging\nlogdir {}\n", self.config.log_dir));
        config.push_str("log tracking measurements statistics\n\n");

        // Clock adjustments
        config.push_str("# Allow system clock to be stepped in the first three updates\n");
        config.push_str("makestep 1.0 3\n\n");

        // RTC sync
        config.push_str("# Enable kernel synchronization of the real-time clock (RTC)\n");
        config.push_str("rtcsync\n\n");

        // Local clock fallback
        if self.config.prefer_local_clock {
            config.push_str("# Use local clock as fallback\n");
            config.push_str(&format!("local stratum {}\n\n", self.config.stratum));
        }

        // Leap second handling
        config.push_str("# Leap second handling\n");
        config.push_str("leapsectz right/UTC\n");

        config
    }

    async fn create_systemd_service(&self) -> Result<()> {
        // chrony usually comes with its own systemd service
        // We'll just ensure it's enabled, not create a new one

        let service = r#"[Unit]
Description=chrony NTP Server
After=network.target
Conflicts=systemd-timesyncd.service ntp.service ntpd.service

[Service]
Type=forking
PIDFile=/var/run/chrony/chronyd.pid
ExecStart=/usr/sbin/chronyd
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=chronyd.service
"#;

        // Only write if doesn't exist
        let service_path = "/etc/systemd/system/chrony.service";
        if !tokio::fs::try_exists(service_path).await.unwrap_or(false) {
            tokio::fs::write(service_path, service).await?;
        }

        Ok(())
    }

    /// Start NTP service
    pub async fn start(&self) -> Result<()> {
        tracing::info!("Starting chrony NTP service");

        // Disable systemd-timesyncd (conflicts with chrony)
        Command::new("systemctl")
            .args(&["stop", "systemd-timesyncd"])
            .status()
            .await?;

        Command::new("systemctl")
            .args(&["disable", "systemd-timesyncd"])
            .status()
            .await?;

        // Start chrony
        let status = Command::new("systemctl")
            .args(&["start", "chronyd"])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to start chrony".to_string()));
        }

        Ok(())
    }

    /// Stop NTP service
    pub async fn stop(&self) -> Result<()> {
        Command::new("systemctl")
            .args(&["stop", "chronyd"])
            .status()
            .await?;

        Ok(())
    }

    /// Restart NTP service
    pub async fn restart(&self) -> Result<()> {
        let status = Command::new("systemctl")
            .args(&["restart", "chronyd"])
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to restart chrony".to_string()));
        }

        Ok(())
    }

    /// Get NTP status
    pub async fn get_status(&self) -> Result<NtpStatus> {
        // Query chronyc for tracking info
        let tracking_output = Command::new("chronyc")
            .arg("tracking")
            .output()
            .await?;

        let tracking_str = String::from_utf8_lossy(&tracking_output.stdout);

        // Query sources
        let sources_output = Command::new("chronyc")
            .args(&["-n", "sources"])
            .output()
            .await?;

        let sources_str = String::from_utf8_lossy(&sources_output.stdout);

        // Parse output
        let status = self.parse_tracking(&tracking_str);
        let sources = self.parse_sources(&sources_str);

        Ok(NtpStatus {
            synchronized: status.0,
            stratum: status.1,
            reference_id: status.2,
            offset: status.3,
            jitter: status.4,
            current_source: status.5,
            sources,
        })
    }

    fn parse_tracking(&self, output: &str) -> (bool, u8, String, f64, f64, Option<String>) {
        let mut synchronized = false;
        let mut stratum = 16;
        let mut reference_id = String::new();
        let mut offset = 0.0;
        let mut jitter = 0.0;
        let mut current_source = None;

        for line in output.lines() {
            if line.starts_with("Reference ID") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() > 3 {
                    reference_id = parts[3].to_string();
                    synchronized = reference_id != "00000000";
                }
            } else if line.starts_with("Stratum") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() > 2 {
                    stratum = parts[2].parse().unwrap_or(16);
                }
            } else if line.starts_with("System time") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() > 3 {
                    offset = parts[3].parse().unwrap_or(0.0);
                }
            } else if line.starts_with("RMS offset") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() > 3 {
                    jitter = parts[3].parse().unwrap_or(0.0);
                }
            }
        }

        (synchronized, stratum, reference_id, offset, jitter, current_source)
    }

    fn parse_sources(&self, output: &str) -> Vec<NtpSourceStatus> {
        let mut sources = Vec::new();

        // Skip header lines
        let lines: Vec<&str> = output.lines().skip(2).collect();

        for line in lines {
            if line.trim().is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() < 9 {
                continue;
            }

            // First char indicates selection (* = current, + = candidate, - = not selected)
            let selected = parts[0].starts_with('*');
            let address = parts[1].to_string();

            sources.push(NtpSourceStatus {
                address,
                stratum: parts[2].parse().unwrap_or(0),
                poll: parts[3].parse().unwrap_or(0),
                reach: parts[4].parse().unwrap_or(0),
                offset: parts[6].parse().unwrap_or(0.0),
                delay: parts[7].parse().unwrap_or(0.0),
                jitter: parts[8].parse().unwrap_or(0.0),
                selected,
            });
        }

        sources
    }

    /// Force time synchronization
    pub async fn force_sync(&self) -> Result<()> {
        tracing::info!("Forcing NTP synchronization");

        let status = Command::new("chronyc")
            .arg("makestep")
            .status()
            .await?;

        if !status.success() {
            return Err(Error::Network("Failed to force sync".to_string()));
        }

        Ok(())
    }

    /// Get list of NTP clients
    pub async fn get_clients(&self) -> Result<Vec<NtpClient>> {
        let output = Command::new("chronyc")
            .arg("clients")
            .output()
            .await?;

        let output_str = String::from_utf8_lossy(&output.stdout);

        let mut clients = Vec::new();

        for line in output_str.lines().skip(2) {
            if line.trim().is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 5 {
                clients.push(NtpClient {
                    address: parts[0].to_string(),
                    ntp_packets: parts[1].parse().unwrap_or(0),
                    cmd_packets: parts[2].parse().unwrap_or(0),
                    drop_count: parts[3].parse().unwrap_or(0),
                    interval: parts[4].parse().unwrap_or(0),
                });
            }
        }

        Ok(clients)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NtpClient {
    pub address: String,
    pub ntp_packets: u64,
    pub cmd_packets: u64,
    pub drop_count: u64,
    pub interval: u32,
}

impl Default for NtpConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            servers: vec![
                NtpServer {
                    address: "0.pool.ntp.org".to_string(),
                    prefer: false,
                    iburst: true,
                    minpoll: 6,
                    maxpoll: 10,
                },
                NtpServer {
                    address: "1.pool.ntp.org".to_string(),
                    prefer: false,
                    iburst: true,
                    minpoll: 6,
                    maxpoll: 10,
                },
                NtpServer {
                    address: "2.pool.ntp.org".to_string(),
                    prefer: false,
                    iburst: true,
                    minpoll: 6,
                    maxpoll: 10,
                },
            ],
            server_mode: true,
            allow_networks: vec![
                "10.0.0.0/8".to_string(),
                "172.16.0.0/12".to_string(),
                "192.168.0.0/16".to_string(),
            ],
            prefer_local_clock: false,
            stratum: 10,
            drift_file: "/var/lib/chrony/drift".to_string(),
            log_dir: "/var/log/chrony".to_string(),
            max_update_skew: 100.0,
        }
    }
}
